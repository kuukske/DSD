-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor IF you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 2018  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, or other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel and sold by Intel or its authorized distributors.  Please
-- refer to the applicable agreement for further details.


-- Generated by Quartus Prime Version 18.1 (Build Build 625 09/12/2018)
-- Created on Tue Nov 27 21:14:20 2018

--Bram Kuijk
--Fontys Engineering

LIBRARY ieee;
USE ieee.std_logic_1164.all;


--  Entity Declaration

ENTITY PWM_Controller IS
-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
PORT
(
CLK : IN STD_LOGIC;
NRST : IN STD_LOGIC;
Init : IN STD_LOGIC;
Avail : IN STD_LOGIC;
Equal : IN STD_LOGIC;
Rdy : OUT STD_LOGIC;
Valid : OUT STD_LOGIC;
Load_1 : OUT STD_LOGIC;
Load_2 : OUT STD_LOGIC;
Clear_cntr : OUT STD_LOGIC;
tri_state_out : OUT STD_LOGIC
);
-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END PWM_Controller;


--  Architecture Body

ARCHITECTURE PWM_Controller_architecture OF PWM_Controller IS

SIGNAL next_state	:	std_logic_vector(2 DOWNTO 0) := "000";
SIGNAL current_state	:	std_logic_vector(2 DOWNTO 0) := "000";

BEGIN
--///////////////////////////////////////////////////////////////////////////
--////////////////////////////NEXT STATE DECODER////////////////////////////
--///////////////////////////////////////////////////////////////////////////
next_state_decoder: PROCESS(Init, Avail, Equal, current_state)
	BEGIN
		CASE current_state IS
			WHEN "000" => 
				IF (Init = '1') AND (Avail = '1') THEN
					next_state <= "001";
				END IF;
				
			WHEN "001" =>
				next_state <= "010";
			
			WHEN "010" =>
				IF (Avail = '0') THEN
					next_state <= "011";
				END IF;
				
			WHEN "011" =>
				IF (Avail = '1') THEN
					next_state <= "100";
				END IF;
			
			WHEN "100" => 
				next_state <= "101";
				
			WHEN "101" =>
				IF (Avail = '0') THEN
					next_state <= "110";
				END IF;
				
			WHEN "110" =>
				IF (Equal = '1') THEN
					next_state <= "110";
				END IF;
					
			WHEN "111" =>
				next_state <= "110";
				
			WHEN OTHERS =>
				next_state <= "000";
		END CASE;
			
	END PROCESS next_state_decoder;

--///////////////////////////////////////////////////////////////////////////
--/////////////////////////CURRENT STATE MACHINE////////////////////////////
--///////////////////////////////////////////////////////////////////////////
current_state_machine: PROCESS(CLK, NRST)
	BEGIN
		IF (NRST = '0') then
			current_state <= "000";
		
		ELSIF (rising_edge(clk)) then
			current_state <= next_state;
		
		END IF;	
	END PROCESS current_state_machine;
	
--///////////////////////////////////////////////////////////////////////////
--/////////////////////////////OUTPUT DECODER///////////////////////////////
--///////////////////////////////////////////////////////////////////////////
output_decoder: PROCESS(current_state, Init, Avail, Equal)
	BEGIN
		CASE current_state IS
			WHEN "000" =>		--S0 | cleare all, reset state
				Rdy 				<=		'0'	;
				Valid				<=		'0'	;
				--Load_1			<=		'0'	;
				Load_2			<=		'0'	;
				Clear_cntr		<=		'0'	;
				tri_state_out	<=		'0'	;
				IF (Init = '1') AND (Avail = '1') THEN		--Mealy transition for Load_1
					Load_1 <= '1';
				ELSE 
					Load_1 <= '0';
				END IF;
			
			WHEN "001" =>		--S1
				Rdy 				<=		'0'	;
				Valid				<=		'0'	;
				Load_1			<=		'1'	;	--load register 1
				Load_2			<=		'0'	;
				Clear_cntr		<=		'1'	;	--clear counter (no count operation)
				tri_state_out	<=		'0'	;
				
			WHEN "010" =>		--S2
				Rdy 				<=		'1'	;	--set ready for handshake
				Valid				<=		'0'	;
				Load_1			<=		'0'	;
				Load_2			<=		'0'	;
				Clear_cntr		<=		'1'	;	--clear counter (no count operation)
				tri_state_out	<=		'0'	;
				
			WHEN "011" =>		--S3
				Rdy 				<=		'0'	;	--clear ready to end handshake
				Valid				<=		'0'	;
				Load_1			<=		'0'	;
				--Load_2			<=		'0'	;
				Clear_cntr		<=		'1'	;	--clear counter (no count operation)
				tri_state_out	<=		'0'	;
				IF (Avail = '1') THEN			--Mealy transition for Load_2
					Load_2 <= '1';
				ELSE 
					Load_2 <= '0';
				END IF;
			
			WHEN "100" =>		--S4
				Rdy 				<=		'0'	;
				Valid				<=		'0'	;
				Load_1			<=		'0'	;
				Load_2			<=		'1'	;	--load register 2
				Clear_cntr		<=		'1'	;	--clear counter (no count operation)
				tri_state_out	<=		'0'	;
			
			WHEN "101" =>		--S5
				Rdy 				<=		'1'	;	--set ready for handshake
				Valid				<=		'0'	;
				Load_1			<=		'0'	;
				Load_2			<=		'0'	;
				Clear_cntr		<=		'1'	;	--clear counter (no count operation)
				tri_state_out	<=		'0'	;
				
			WHEN "110" =>		--S6
				Rdy 				<=		'0'	;	--clear ready to end handshake
				Valid				<=		'1'	;	--enable valid output 
				Load_1			<=		'0'	;
				Load_2			<=		'0'	;
				--Clear_cntr		<=		'0'	;	--start counting
				tri_state_out	<=		'1'	;	--enable output tri-state buffer
				IF (Equal = '1') THEN			--Mealy transistion for Clear_cntr
					Clear_cntr <= '1';
				ELSE
					Clear_cntr <= '0';
				END IF;
			
			
--			WHEN "111" =>		--S7
--				Rdy 				<=		'0'	;	
--				Valid				<=		'1'	;	--keep valid output enabled
--				Load_1			<=		'0'	;
--				Load_2			<=		'0'	;
--				Clear_cntr		<=		'1'	;	--clear counter, reset for next count cycle
--				tri_state_out	<=		'1'	;	--keep tri-state buffer output enabled
				
			WHEN OTHERS =>
				Rdy 				<=		'X'	;
				Valid				<=		'X'	;
				Load_1			<=		'X'	;
				Load_2			<=		'X'	;
				Clear_cntr		<=		'X'	;
				tri_state_out	<=		'X'	;
		END CASE;
		
	END PROCESS output_decoder;


END PWM_Controller_architecture;














